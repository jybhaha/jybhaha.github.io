<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Jiao" />
        <meta name="copyright" content="Jiao" />

        
<meta name="keywords" content=", Misc, " />
        <title>一篇文章带你读懂windows多线程  · Jiao's Blog
</title>
        <link href="http://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://jybhaha.github.io/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://jybhaha.github.io/theme/css/pygments.css" media="screen">
        
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://jybhaha.github.io/"><span class=site-name><span style="color:black;">Jiao's </span> <span style="color:#AA1032;">Blog</span></span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://jybhaha.github.io">Home</a></li>
                            <li ><a href="http://jybhaha.github.io/categories.html">Categories</a></li>
                            <li ><a href="http://jybhaha.github.io/about.html">about</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="http://jybhaha.github.io/yi-pian-wen-zhang-dai-ni-du-dong-windowsduo-xian-cheng.html"> 一篇文章带你读懂windows多线程  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#windows">windows 多线程</a><ul>
<li><a href="#_1">概念</a></li>
<li><a href="#_2">多线程</a><ul>
<li><a href="#_3">同步和互斥</a></li>
<li><a href="#critical-section">Critical Section 临界区（也叫关键代码段）</a></li>
<li><a href="#event">Event 事件</a></li>
<li><a href="#mutex">mutex 互斥</a></li>
<li><a href="#semaphore">Semaphore 信号量</a></li>
</ul>
</li>
<li><a href="#_4">应用</a><ul>
<li><a href="#_5">生产者消费者问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            <h1 id="windows">windows 多线程<a class="headerlink" href="#windows" title="Permanent link">¶</a></h1>

<hr/>
<h2 id="_1">概念<a class="headerlink" href="#_1" title="Permanent link">¶</a></h2>
<p>首先了解一下进程和线程的概念：</p>
<blockquote>
<ul>
<li>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
</li>
<li>
<p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
</li>
</ul>
</blockquote>
<p>值得注意的是：</p>
<p><strong>进程只是一个容器并不会真正执行代码，执行代码的是线程。线程在进程的环境中创建，同一进程中的线程环境、资源等基本相同，所以很容易实现通信。</strong></p>
<h2 id="_2">多线程<a class="headerlink" href="#_2" title="Permanent link">¶</a></h2>
<p>为什么使用多线程:</p>
<ul>
<li>和进程相比，线程花费更小，切换快。</li>
<li>在C/S架构中的服务器端并发线程相应用户请求。</li>
<li>耗时的操作使用线程，提高程序相应速</li>
<li>多CPU系统中，提高CPU利用率</li>
</ul>
<p>多线程有这么多好处，但如果不采取适当的措施，其他线程往往会在线程处理任务结束前就去访问处理结果，这就很有可能得到有关处理结果的错误了解。例如，多个线程同时访问同一个全局变量，如果都是读取操作，则不会出现问题。如果一个线程负责改变此变量的值，而其他线程负责同时读取变量内容，则不能保证读取到的数据是经过写线程修改后的。</p>
<p>为了确保读线程读取到的是经过修改的变量，就必须在向变量写入数据时禁止其他线程对其的任何访问，直至赋值过程结束后再解除对其他线程的访问限制。象这种保证线程能了解其他线程任务处理结束后的处理结果而采取的保护措施即为<strong>线程同步</strong>。</p>
<p>线程的同步可分<strong>用户模式</strong>的线程同步和<strong>内核对象</strong>的线程同步两大类。用户模式中线程的同步方法主要有原子访问和临界区等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。</p>
<p>内核对象的线程同步则主要由事件、等待定时器、信号量以及信号灯等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。</p>
<h3 id="_3">同步和互斥<a class="headerlink" href="#_3" title="Permanent link">¶</a></h3>
<p>当线程并发执行时，由于资源共享和线程协作，使用线程之间会存在以下两种制约关系。</p>
<ol>
<li>
<p>间接相互制约。一个系统中的多个线程必然要共享某种系统资源，如共享CPU，共享I/O设备，所谓间接相互制约即源于这种资源共享，打印机就是最好的例子，线程A在使用打印机时，其它线程都要等待。</p>
</li>
<li>
<p>直接相互制约。这种制约主要是因为线程之间的合作，如有线程A将计算结果提供给线程B作进一步处理，那么线程B在线程A将数据送达之前都将处于阻塞状态。</p>
</li>
</ol>
<p>间接相互制约可以称为互斥，直接相互制约可以称为同步，对于互斥可以这样理解，线程A和线程B互斥访问某个资源则它们之间就会产个顺序问题——要么线程A等待线程B操作完毕，要么线程B等待线程操作完毕，这其实就是线程的同步了。</p>
<p><strong>因此同步包括互斥，互斥其实是一种特殊的同步。</strong></p>
<p>四种进程或线程同步互斥的控制方法</p>
<ol>
<li>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </li>
<li>互斥量：为协调共同对一个共享资源的单独访问而设计的。 </li>
<li>信号量：为控制一个具有有限数量用户资源而设计。 </li>
<li>事 件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ol>
<p><strong>可以看出临界区和互斥量是用来实现互斥的，信号量和事件主要是用来实现同步的</strong></p>
<p>临界区（Critical Section）（<em>同一个进程内，实现互斥</em>）</p>
<p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p>
<p>互斥量（Mutex）（<em>可以跨进程，实现互斥</em>）</p>
<p>互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>
<p>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</p>
<p>信号量（Semaphores）（<em>主要是实现同步，可以跨进程</em>）</p>
<p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。</p>
<p>事件（Event）（<em>实现同步，可以跨进程</em>）</p>
<p>事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。</p>
<h3 id="critical-section">Critical Section   临界区（也叫关键代码段）<a class="headerlink" href="#critical-section" title="Permanent link">¶</a></h3>
<p>很多人在电话亭外边排队打电话，我进去打电话了，就不想你也过来凑热闹，就把亭子的门关上，防止别人过来偷听。</p>
<p>临界区就是这么一个作用。</p>
<p>临界区，就是指一小段代码，在代码能够执行前需要独占某些资源的访问权。</p>
<p>临界区实现起来是最简单的。</p>
<p>只需要四个函数。</p>
<p>函数功能：初始化</p>
<p>函数原型：</p>
<p>void InitializeCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);</p>
<p>函数说明：定义关键段变量后必须先初始化。</p>
<p>函数功能：销毁</p>
<p>函数原型：</p>
<p>void DeleteCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);</p>
<p>函数说明：用完之后记得销毁。</p>
<p>函数功能：进入关键区域</p>
<p>函数原型：</p>
<p>void EnterCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);</p>
<p>函数说明：系统保证各线程互斥的进入关键区域。</p>
<p>函数功能：离开关关键区域</p>
<p>函数原型：</p>
<p>void LeaveCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**************************************************************</span>
<span class="cm">代码处处：http://blog.csdn.net/morewindows/article/details/7442639</span>
<span class="cm">略作修改</span>
<span class="cm">****************************/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;process.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="kt">long</span> <span class="n">g_nNum</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pPM</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">THREAD_NUM</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">//关键段变量声明</span>
<span class="n">CRITICAL_SECTION</span>  <span class="n">g_csThreadParameter</span><span class="p">,</span> <span class="n">g_csThreadCode</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"     经典线程同步 关键段</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">//关键段初始化</span>
    <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadParameter</span><span class="p">);</span>
    <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>

    <span class="n">HANDLE</span>  <span class="n">handle</span><span class="p">[</span><span class="n">THREAD_NUM</span><span class="p">];</span>
    <span class="n">g_nNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadParameter</span><span class="p">);</span><span class="c1">//进入子线程序号关键区域</span>
        <span class="n">handle</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="n">THREAD_NUM</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

    <span class="n">DeleteCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>
    <span class="n">DeleteCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadParameter</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pPM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nThreadNum</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">pPM</span><span class="p">;</span>
    <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadParameter</span><span class="p">);</span><span class="c1">//离开子线程序号关键区域</span>

    <span class="n">Sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span><span class="c1">//some work should to do</span>

    <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span><span class="c1">//进入各子线程互斥区域</span>
    <span class="n">g_nNum</span><span class="o">++</span><span class="p">;</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//some work should to do</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"线程编号为%d  全局资源值为%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nThreadNum</span><span class="p">,</span> <span class="n">g_nNum</span><span class="p">);</span>
    <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span><span class="c1">//离开各子线程互斥区域</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-------------------------</span><span class="err">输出结果</span><span class="o">--------------------------</span>
     <span class="err">经典线程同步</span> <span class="err">关键段</span>
 <span class="o">--</span> <span class="n">by</span> <span class="n">MoreWindows</span><span class="p">(</span> <span class="nl">http</span><span class="p">:</span><span class="c1">//blog.csdn.net/MoreWindows ) --</span>
<span class="err">线程编号为</span><span class="mi">1</span>  <span class="err">全局资源值为</span><span class="mi">1</span>
<span class="err">线程编号为</span><span class="mi">2</span>  <span class="err">全局资源值为</span><span class="mi">2</span>
<span class="err">线程编号为</span><span class="mi">3</span>  <span class="err">全局资源值为</span><span class="mi">3</span>
<span class="err">线程编号为</span><span class="mi">4</span>  <span class="err">全局资源值为</span><span class="mi">4</span>
<span class="err">线程编号为</span><span class="mi">5</span>  <span class="err">全局资源值为</span><span class="mi">5</span>
<span class="err">线程编号为</span><span class="mi">6</span>  <span class="err">全局资源值为</span><span class="mi">6</span>
<span class="err">线程编号为</span><span class="mi">7</span>  <span class="err">全局资源值为</span><span class="mi">7</span>
<span class="err">线程编号为</span><span class="mi">8</span>  <span class="err">全局资源值为</span><span class="mi">8</span>
<span class="err">线程编号为</span><span class="mi">9</span>  <span class="err">全局资源值为</span><span class="mi">9</span>
<span class="err">线程编号为</span><span class="mi">10</span>  <span class="err">全局资源值为</span><span class="mi">10</span>
<span class="err">请按任意键继续</span><span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
</pre></div>
</td></tr></table>
<p>但值得注意的是，使用临界区的时候，要注意避免<strong>死锁</strong>的出现。</p>
<p>例如，有两个临界区资源时，A和B都想申请。会有这么一种情况出现：</p>
<blockquote>
<p>A占有了临界区1的资源，等待着临界区2的资源； B占有了临界区2的资源，等待着临界区1的资源。</p>
</blockquote>
<p>这时候程序就会进入<strong>死锁</strong>。</p>
<h3 id="event">Event 事件<a class="headerlink" href="#event" title="Permanent link">¶</a></h3>
<p>事件是一个内核对象。 用于表明改时间是否处于已通知状态还是未通知状态。</p>
<p>事件有两种类型：</p>
<blockquote>
<p>人工重置的事件类型：此事件得到通知时，等待事件对象的所有线程均变为可调度线程。 自动充值的事件类型：此事件得到通知时，等待该对象的一个线程变为可调度线程。</p>
</blockquote>
<p>使用事件对象的五个函数。
函数功能：创建事件对象 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span>HANDLE CreateEvent(
         LPSECURITY_ATTRIBUTES lpEventAttributes, //一般设为NULL，默认的
        BOOL bManualReset,   //TRUE:人工重置对象   FALSE:自动重置对象
        BOOL bInitialState,     //TRUE：事件对象初始为有信号状态
        LPCTSTR lpName    //事件对象名称，NULL为匿名
);
</pre></div>
</td></tr></table>
<p>函数功能：设置事件为有信号状态
函数原型：
<code>BOOL SetEvent(HANDLE hEvent)</code>
函数功能：设置事件为无信号状态
函数原型：
<code>BOOL ResetEvent(HANDLE hEvent)</code>
函数功能：等待获得事件所有权 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>DWORD WaitForSingleObject(
    HANDLE hHandle, //传入句柄
     DWORD dwMilliseconds //等待的时间间隔
);
</pre></div>
</td></tr></table>
<p>代码实现：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tickets</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">gEvent</span><span class="p">;</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun1Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun2Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hThread1</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hThread2</span><span class="p">;</span>

    <span class="n">gEvent</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">hThread1</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun1Proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">hThread2</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun2Proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>\

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread1</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread2</span><span class="p">);</span>

    <span class="n">Sleep</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun1Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">gEvent</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="n">resetEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>       
        <span class="k">if</span> <span class="p">(</span><span class="n">tickets</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"thread1:  "</span> <span class="o">&lt;&lt;</span> <span class="n">tickets</span><span class="o">--</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">SetEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">SetEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun2Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">gEvent</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="n">resEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tickets</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"thread2:  "</span> <span class="o">&lt;&lt;</span> <span class="n">tickets</span><span class="o">--</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csA</span><span class="p">);</span>
            <span class="n">SetEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">SetEvent</span><span class="p">(</span><span class="n">gEvent</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">----------------</span><span class="err">输出结果</span><span class="o">--------------------------</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">20</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">19</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">18</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">17</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">16</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">15</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">14</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">13</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">12</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">11</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">10</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">9</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">8</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">7</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">6</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">5</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">4</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">3</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">2</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">1</span>
<span class="err">请按任意键继续</span><span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
</pre></div>
</td></tr></table>
<p><strong>gEvent = CreateEvent(<span class="caps">NULL</span>, <span class="caps">FALSE</span>, <span class="caps">TRUE</span>, <span class="caps">NULL</span>);</strong></p>
<p><strong>这里第二个参数需要注意：</strong></p>
<p>若为False：设置为自动重置使劲按对象，等待的线程只有一个变为可调度线程</p>
<p>若为TURE，设置为人工重置的事件对象，所有线程设置均变为可调度线程，</p>
<p><strong>为了实现线程间的同步，应该使用自动重置的事件对象。</strong></p>
<p>若是第二个参数设置为TURE，输出结果为：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">thread1</span><span class="o">:</span>  <span class="mi">20</span>
<span class="n">thread1</span><span class="o">:</span>  <span class="mi">19</span><span class="n">thread2</span><span class="o">:</span>  <span class="mi">18</span>

<span class="n">thread1</span><span class="o">:</span>  <span class="mi">17</span>
<span class="n">thread2</span><span class="o">:</span>  <span class="mi">17</span>
<span class="n">thread1</span><span class="o">:</span>  <span class="mi">16</span><span class="n">thread2</span><span class="o">:</span>  <span class="mi">15</span>

<span class="n">thread2</span><span class="o">:</span>  <span class="mi">14</span>
<span class="n">thread1</span><span class="o">:</span>  <span class="mi">13</span>
<span class="n">thread2</span><span class="o">:</span>  <span class="mi">11</span><span class="n">thread1</span><span class="o">:</span>  <span class="mi">12</span>

<span class="n">thread1</span><span class="o">:</span>  <span class="mi">10</span><span class="n">thread2</span><span class="o">:</span>  <span class="mi">10</span>

<span class="n">thread2</span><span class="o">:</span>  <span class="mi">9</span><span class="n">thread1</span><span class="o">:</span>  <span class="mi">8</span>

<span class="n">thread1</span><span class="o">:</span>  <span class="mi">7</span>
<span class="n">thread2</span><span class="o">:</span>  <span class="mi">6</span>
<span class="n">thread1</span><span class="o">:</span>  <span class="mi">4</span><span class="n">thread2</span><span class="o">:</span>  <span class="mi">5</span>

<span class="n">thread2</span><span class="o">:</span>  <span class="mi">3</span><span class="n">thread1</span><span class="o">:</span>  <span class="mi">3</span>

<span class="n">thread2</span><span class="o">:</span>  <span class="mi">1</span>
<span class="n">thread1</span><span class="o">:</span>  <span class="mi">2</span>
<span class="err">请按任意键继续</span><span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</td></tr></table>
<p>可看出程序并没有实现同步。</p>
<p>第三个对象，这里应该设置为true，有信号状态。若设置为无信号状态，会发现程序不会执行，因为无信号状态下，两个函数都会一直处于等待的状态。</p>
<h3 id="mutex">mutex 互斥<a class="headerlink" href="#mutex" title="Permanent link">¶</a></h3>
<p>互斥（Mutex）是一种用途非常广泛的内核对象。能够保证多个线程对同一共享资源的互斥访问。同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。</p>
<p>实现互斥量，需要五个基本函数。</p>
<p>CreateMutex
函数功能：创建互斥量 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>HANDLECreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,//表示安全控制，一般直接传入NULL。
  BOO LbInitialOwner,  

   /*
  TRUE: 互斥量对象内部会记录创建它的线程的线程ID号并将递归计数设置为1，由于该线程ID非零，所以互斥量处于未触发状态。FALSE: 那么互斥量对象内部的线程ID号将设置为NULL，递归计数设置为0，这意味互斥量不为任何线程占用，处于触发状态。
  */

  LPCTSTR lpName //互斥量的名称
);
</pre></div>
</td></tr></table>
<p>函数功能：等待获得事件所有权 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>DWORD WaitForSingleObject(
    HANDLE hHandle, //传入句柄
     DWORD dwMilliseconds //等待的时间间隔
);
</pre></div>
</td></tr></table>
<p>释放互斥量
函数原型：
<code>BOOL ReleaseMutex (HANDLEhMutex)</code>
函数说明： 访问互斥资源前应该要调用等待函数，结束访问时就要调用ReleaseMutex()来表示自己已经结束访问，其它线程可以开始访问了。</p>
<p>清理互斥量 由于互斥量是内核对象，因此使用CloseHandle()就可以（这一点所有内核对象都一样）。</p>
<p>代码实现</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tickets</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">mMutex</span><span class="p">;</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun1Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun2Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hThread1</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hThread2</span><span class="p">;</span>    
    <span class="n">mMutex</span> <span class="o">=</span> <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">hThread1</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun1Proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">hThread2</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun2Proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="err">\</span> 
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread1</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread2</span><span class="p">);</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun1Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">mMutex</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   
        <span class="k">if</span> <span class="p">(</span><span class="n">tickets</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"thread1:  "</span> <span class="o">&lt;&lt;</span> <span class="n">tickets</span><span class="o">--</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ReleaseMutex</span><span class="p">(</span><span class="n">mMutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Fun2Proc</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">mMutex</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tickets</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"thread2:  "</span> <span class="o">&lt;&lt;</span> <span class="n">tickets</span><span class="o">--</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ReleaseMutex</span><span class="p">(</span><span class="n">mMutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">---------------------</span><span class="err">输出结果</span><span class="o">----------------------------</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">20</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">19</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">18</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">17</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">16</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">15</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">14</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">13</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">12</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">11</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">10</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">9</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">8</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">7</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">6</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">5</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">4</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">3</span>
<span class="nl">thread1</span><span class="p">:</span>  <span class="mi">2</span>
<span class="nl">thread2</span><span class="p">:</span>  <span class="mi">1</span>
<span class="err">请按任意键继续</span><span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
</pre></div>
</td></tr></table>
<p><strong>注意：</strong></p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>while (TRUE)
    {
        WaitForSingleObject(mMutex, INFINITE);
        ...
</pre></div>
</td></tr></table>
<p>变成—》</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>WaitForSingleObject(mMutex, INFINITE);
while (TRUE)
    {
        ...
输出结果会变为：
thread1:  20
thread1:  19thread2:  18

thread2:  16thread1:  17

thread2:  14thread1:  15

thread2:  13
thread1:  12
thread2:  11thread1:  11

thread2:  9thread1:  9

thread2:  7
thread1:  6
thread2:  5
thread1:  4
thread2:  3
thread1:  2
thread2:  1
thread1:  0
请按任意键继续. . .
</pre></div>
</td></tr></table>
<p>会发现就是没有增加互斥的结果。</p>
<h3 id="semaphore">Semaphore  信号量<a class="headerlink" href="#semaphore" title="Permanent link">¶</a></h3>
<p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。</p>
<p>需要用到的函数：</p>
<p><strong>CreateSemaphore</strong></p>
<p>函数功能：创建信号量 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span>HANDLE CreateSemaphore(
  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // 安全控制，一般直接传入NULL。
  LONG lInitialCount, //初始资源数量。
  LONG lMaximumCount, //最大并发数量。
  LPCTSTR lpName  //信号量的名称，传入NULL表示匿名信号量。
);
</pre></div>
</td></tr></table>
<p><strong>ReleaseSemaphore</strong></p>
<p>函数功能：递增信号量的当前资源计数</p>
<p>函数原型：
”’
<span class="caps">BOOL</span> ReleaseSemaphore(
  <span class="caps">HANDLE</span> hSemaphore, //信号量的句柄
  <span class="caps">LONG</span> lReleaseCount,  //表示增加个数，必须大于0且不超过最大资源数量。
  <span class="caps">LPLONG</span> lpPreviousCount  //传出先前的资源计数，设为NULL表示不需要传出。
);
”’
函数功能：等待获得事件所有权 函数原型：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>DWORD WaitForSingleObject(
    HANDLE hHandle, //传入句柄
     DWORD dwMilliseconds //等待的时间间隔
);
</pre></div>
</td></tr></table>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">* 代码出处：http://blog.csdn.net/morewindows/article/details/7481609</span>
<span class="cm">* 略作改动</span>
<span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;process.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="kt">long</span> <span class="n">g_nNum</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pPM</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">THREAD_NUM</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">//信号量与关键段</span>
<span class="n">HANDLE</span>            <span class="n">g_hThreadParameter</span><span class="p">;</span>
<span class="n">CRITICAL_SECTION</span>  <span class="n">g_csThreadCode</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//初始化信号量和关键段</span>
    <span class="n">g_hThreadParameter</span> <span class="o">=</span> <span class="n">CreateSemaphore</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="c1">//当前0个资源，最大允许1个同时访问</span>
    <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>

    <span class="n">HANDLE</span>  <span class="n">handle</span><span class="p">[</span><span class="n">THREAD_NUM</span><span class="p">];</span> 
    <span class="n">g_nNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">handle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">g_hThreadParameter</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span><span class="c1">//等待信号量&gt;0，实现同步重要步骤，防止其他线程占用资源</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="n">THREAD_NUM</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

    <span class="c1">//销毁信号量和关键段</span>
    <span class="n">DeleteCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">g_hThreadParameter</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pPM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nThreadNum</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">pPM</span><span class="p">;</span>
    <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">g_hThreadParameter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="c1">//信号量++</span>

    <span class="n">Sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span><span class="c1">//some work should to do</span>

    <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>
    <span class="o">++</span><span class="n">g_nNum</span><span class="p">;</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//some work should to do</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"线程编号为%d  全局资源值为%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nThreadNum</span><span class="p">,</span> <span class="n">g_nNum</span><span class="p">);</span>
    <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_csThreadCode</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
<p>上述代码使用信号量和关键代码段实现同步。</p>
<h2 id="_4">应用<a class="headerlink" href="#_4" title="Permanent link">¶</a></h2>
<p>介绍了四种实现同步的方法后，来看看如何应用。</p>
<h3 id="_5">生产者消费者问题<a class="headerlink" href="#_5" title="Permanent link">¶</a></h3>
<p>有一个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费，显然生产者和消费者之间必须保持同步，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个已经放入产品的缓冲区中再次投放产品。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">*代码来自：http://blog.csdn.net/morewindows/article/details/7577591</span>
<span class="cm">*略作修改</span>
<span class="cm">*/</span>
<span class="c1">//1生产者 2消费者 4缓冲区</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;process.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="c1">//设置控制台输出颜色</span>
<span class="n">BOOL</span> <span class="nf">SetConsoleColor</span><span class="p">(</span><span class="n">WORD</span> <span class="n">wAttributes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hConsole</span> <span class="o">=</span> <span class="n">GetStdHandle</span><span class="p">(</span><span class="n">STD_OUTPUT_HANDLE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hConsole</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">SetConsoleTextAttribute</span><span class="p">(</span><span class="n">hConsole</span><span class="p">,</span> <span class="n">wAttributes</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">END_PRODUCE_NUMBER</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">//生产产品个数</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>          <span class="c1">//缓冲区个数</span>
<span class="kt">int</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>          <span class="c1">//缓冲池</span>
<span class="kt">int</span> <span class="n">g_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">g_j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">//信号量与关键段</span>
<span class="n">CRITICAL_SECTION</span> <span class="n">g_cs</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">g_hSemaphoreBufferEmpty</span><span class="p">,</span> <span class="n">g_hSemaphoreBufferNotEmpty</span><span class="p">;</span>
<span class="c1">//生产者线程函数</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">ProducerThreadFun</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">pM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">END_PRODUCE_NUMBER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//等待有空的缓冲区出现</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">g_hSemaphoreBufferEmpty</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="c1">//互斥的访问缓冲区</span>
        <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>
        <span class="n">g_Buffer</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"生产者在缓冲池第%d个缓冲区中投放数据%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">g_i</span><span class="p">]);</span>
        <span class="n">g_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
        <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>

        <span class="c1">//通知消费者有新数据了</span>
        <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">g_hSemaphoreBufferNotEmpty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"生产者完成任务，线程结束运行</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//消费者线程函数</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">ConsumerThreadFun</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">pM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//等待非空的缓冲区出现</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">g_hSemaphoreBufferNotEmpty</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="c1">//互斥的访问缓冲区</span>
        <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>
        <span class="n">SetConsoleColor</span><span class="p">(</span><span class="n">FOREGROUND_GREEN</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  编号为%d的消费者从缓冲池中第%d个缓冲区取出数据%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetCurrentThreadId</span><span class="p">(),</span> <span class="n">g_j</span><span class="p">,</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">g_j</span><span class="p">]);</span>
        <span class="n">SetConsoleColor</span><span class="p">(</span><span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="o">|</span> <span class="n">FOREGROUND_BLUE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_Buffer</span><span class="p">[</span><span class="n">g_j</span><span class="p">]</span> <span class="o">==</span> <span class="n">END_PRODUCE_NUMBER</span><span class="p">)</span><span class="c1">//结束标志</span>
        <span class="p">{</span>
            <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>
            <span class="c1">//通知其它消费者有新数据了(结束标志)</span>
            <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">g_hSemaphoreBufferNotEmpty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">g_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
        <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>

        <span class="n">Sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span> <span class="c1">//some other work to do</span>

        <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">g_hSemaphoreBufferEmpty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SetConsoleColor</span><span class="p">(</span><span class="n">FOREGROUND_GREEN</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  编号为%d的消费者收到通知，线程结束运行</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetCurrentThreadId</span><span class="p">());</span>
    <span class="n">SetConsoleColor</span><span class="p">(</span><span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="o">|</span> <span class="n">FOREGROUND_BLUE</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  生产者消费者问题   1生产者 2消费者 10缓冲区</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_cs</span><span class="p">);</span>
    <span class="c1">//初始化信号量,一个记录有产品的缓冲区个数,另一个记录空缓冲区个数.</span>
    <span class="n">g_hSemaphoreBufferEmpty</span> <span class="o">=</span> <span class="n">CreateSemaphore</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">g_hSemaphoreBufferNotEmpty</span> <span class="o">=</span> <span class="n">CreateSemaphore</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">));</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">THREADNUM</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">[</span><span class="n">THREADNUM</span><span class="p">];</span>
    <span class="c1">//生产者线程</span>
    <span class="n">hThread</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ProducerThreadFun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">//消费者线程</span>
    <span class="n">hThread</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ConsumerThreadFun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">hThread</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ConsumerThreadFun</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="n">THREADNUM</span><span class="p">,</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREADNUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">//销毁信号量和关键段</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">g_hSemaphoreBufferEmpty</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">g_</span>
</pre></div>
</td></tr></table>
            
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2016-09-08T00:00:00+08:00">9月 8, 2016</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#Misc-ref">Misc</a> 

        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
        <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>
    </body>
</html>